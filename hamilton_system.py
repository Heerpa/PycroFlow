"""
address are unique to the whole system (same as serial address)


"""
import PyHamiltonPSD as ham
from .PyHamiltonMVP import MVP
from PyHamiltonPSD.util import SyringeMovement as SyrMov
from PyHamiltonPSD.util import SyringeTypes as SyrTypes
from PyHamiltonPSD.util import PSDTypes
import numpy as np


"""Legacy system architecture:
* N valves for N*6+1 reservoirs ('valve_a')
* 1 syringe pump ('pump_a')
* sample
* 1 syringe pump ('pump_out')
* waste
"""
legacy_system_config = {
    'system_type': 'legacy',
    'valve_a': [
        {'address': 0, 'intrument_type': 'MVP', 'valve_type': '8-5'},
        {'address': 1, 'intrument_type': 'MVP', 'valve_type': '8-5'},
        ],
    'pump_a': {'address': 2, 'instrument_type': '4', 'valve_type': 'Y', 'syringe': '500u'},
    'pump_out': {'address': 3, 'instrument_type': '4', 'valve_type': 'Y', 'syringe': '5.0m'},
    'reservoir_a': [
        {'id': 0, 'valve_pos': {0: 3, 1: 2}},
        {'id': 1, 'valve_pos': {0: 2, 1: 2}},
        ],
    'flushbuffer_a': 0,  # defines the reservoir id with the buffer that can be used for flushing
}

# description of tubing volumes between
# reservoirs -> confluxes(if present) -> pumps
# connections are set fixed for each system architecture
legacy_tubing_config = {
    (0, 'pump_a'): 153.2,
    (1, 'pump_a'): 151.8,
    ('pump_a', 'sample'): 30.7,
}

"""the 'flattened protocol' (in contrast to the 'aggregated' Exchange/MERPAINT protocol
specified by the user)
This is the protocol generated by the 'upper system' from the aggregated protocol.
Protocol entries are stepped through in the upper system, calling 'LegacyArchitecture'
for the fluid-control steps.
"""
protocol = {
    'flow_parameters': {
        'start_velocity': 50,
        'max_velocity': 1000,
        'stop_velocity': 500,
        'extractionfactor': 2},
    'imaging': {
        'frames': 30000,
        't_exp': 100},
    'protocol_entries': [
        {'type': 'dispense', 'reservoir_id': 0, 'volume': 500},
        {'type': 'dispense', 'reservoir_id': 1, 'volume': 500, 'velocity': 600},
        {'type': 'acquire', 'frames': 10000, 't_exp': 100, 'round': 1},
        {'type': 'dispense', 'reservoir_id': 0, 'volume': 500},   # for more commplex system: 'mix'
    ]}


def map_valve_type(valve):
    vmap = {
        '1': '1', 'Y': '1',
        '2': '2', 'T': '2', '3-3': '2',
        '3': '3', '3-5': '3',
        '4': '4', '4-2': '4', '4-5': '4',
        '5': '5', '6-5': '5',
        '6': '6', '8-5': '6'}
    return vmap[valve]


class Reservoir():
    """Representation of a fluid reservoir
    """

    def __init__(self, id, valve_positions):
        self.id = id
        self.valve_positions = valve_positions

    def get_valve_positions(self):
        return self.valve_positions


class Valve():
    def __init__(self, address, instrument_type='4', valve_type='1'):
        """
        Args:
            addresss : char
                instrument address as set on address switch, '0' to 'F'
            instrument_type : str
                one of ['MVP']
            valve_type : str
                one of (as described in PSD3 manual, p. 15)
                val: alt   : description                           DIP Switch
                '1': 'Y'   : 3-Port Y Valve                        OFF OFF OFF
                '2': 'T', '3-3' : T-Port Valve                     ON  OFF OFF
                '3': '3-5' : 3-Port Distribution Valve             OFF ON  OFF
                '4': '4-2', '4-5': 4-Port Dist / 4-Port Wash Valve OFF OFF ON
                '5': '6-5' : 6-Port Distribution Valve             OFF ON  ON
                '6': '8-5' : 8-Port Distribution Valve             ON  ON  OFF
                Hopefully same as for PSD?
                However, it is unclear whether these values actually need to be
                set, as they are set on the DIP switch (PSD manual, p.15)

        """
        assert instrument_type == 'MVP'

        self.mvp = MVP(address, instrument_type)
        ham.communication.sendCommand(
            self.mvp.asciiAddress,
            self.mvp.command.enableHFactorCommandsAndQueries()
            + self.mvp.command.executeCommandBuffer())
        valve_type = map_valve_type(valve_type)

    def set_valve(self, pos):
        """Sets the valve position of the PSD.
        Args:
            pos : str
                one of 'in' or 'out', or a position between 1 and 8
        """
        assert pos in ['in', 'out', *list(range(1, 9))]
        if pos == 'in':
            cmd = self.mvp.command.moveValveToInputPosition()
        elif pos == 'out':
            cmd = self.mvp.command.moveValveToOutputPosition()
        else:
            cmd = self.mvp.command.moveValveInShortestDirection(pos)
        ham.communication.sendCommand(
            self.mvp.asciiAddress,
            cmd + self.mvp.command.executeCommandBuffer(),
            waitForPump=False)


class Pump():
    def __init__(self, address, syringe,
                 instrument_type='4', valve_type='1', resolution_mode=1):
        """
        Args:
            addresss : char
                instrument address as set on address switch, '0' to 'F'
            syringe : char
                The syringe type/volume
                '12.5u', '25u', '50u', '100u', '125u', '250u', '500u',
                '1.0m', '2.5m', '5.0m', '10m', '25m', '50m'
            instrument_type : str
                one of
                '4' (PSD4), '6' (PSD6), '4sf' (PSD4 smooth flow),
                '6sf' (PSD6 smooth flow)
            valve_type : str
                one of
                '1': 3-Port Y Valve
                '2': T-Port Valve
                '3': 3-Port Distribution Valve
                '4': 4-Port Distribution Valve 4-Port Wash Valve
                '5': 6-Port Distribution Valve
                '6': 8-Port Distribution Valve
                However, it is unclear whether these values actually need to be
                set, as they are set on the DIP switch (PSD manual, p.15)
            resolution_mode : int
                0: standard resolution (0-3000 steps)
                1: high resolution mode (0-24000 steps)
                Not sure this can be freely chosen or depends on hardware
                (but it is not the distinction between PSD4 and PSD4 smooth
                flow!)
        """
        assert instrument_type in [member.value for member in PSDTypes]
        assert syringe in [member.value for member in SyrTypes]
        self.psd = ham.PSD(address, instrument_type)
        ham.communication.sendCommand(
            self.psd.asciiAddress,
            self.psd.command.enableHFactorCommandsAndQueries()
            + self.psd.command.executeCommandBuffer())
        # ham.communication.sendCommand(
        #     self.psd.asciiAddress,
        #     self.psd.command.standardHighResolutionSelection(resolution_mode),
        #     waitForPump=True)
        result = ham.communication.sendCommand(
            self.psd.asciiAddress,
            self.psd.command.syringeModeQuery(),
            waitForPump=True)
        resolution = result[3:4]
        self.psd.setResolution(int(resolution))
        self.psd.calculateSteps()
        self.psd.calculateSyringeStroke()
        self.psd.setVolume(syringe)

    def dispense(self, vol, velocity=None):
        if velocity is not None:
            cmd = self.psd.command.setMaximumVelocity(velocity)
        else:
            cmd = ''
        cmd += self.psd.command.syringeMovement(SyrMov.relativeDispense, vol)
        cmd += self.psd.command.executeCommandBuffer()
        ham.communication.sendCommand(
            self.psd.asciiAddress, cmd, waitForPump=False)

    def pickup(self, vol, velocity=None):
        if velocity is not None:
            cmd = self.psd.command.setMaximumVelocity(velocity)
        else:
            cmd = ''
        cmd += self.psd.command.syringeMovement(SyrMov.relativePickup, vol)
        cmd += self.psd.command.executeCommandBuffer()
        ham.communication.sendCommand(
            self.psd.asciiAddress, cmd, waitForPump=False)

    def set_velocity(self, start_velocity, max_velocity, stop_velocity):
        """Set movement start, max, and stop velocities
        Args:
            start_velocity : int
                50-1000
            max_velocity : int
                2-5800
            stop_velocity : int
                50-2700
        """
        ham.communication.sendCommand(
            self.psd.asciiAddress,
            + self.psd.command.setStartVelocity(start_velocity)
            + self.psd.command.setMaximumVelocity(max_velocity)
            + self.psd.command.setStopVelocity(stop_velocity)
            + self.psd.command.executeCommandBuffer(),
            waitForPump=False)

    def set_valve(self, pos):
        """Sets the valve position of the PSD.
        Args:
            pos : str
                one of 'in' or 'out'
        """
        assert pos in ['in', 'out']
        if pos == 'in':
            cmd = self.psd.command.moveValveToInputPosition()
        else:
            cmd = self.psd.command.moveValveToOutputPosition()
        ham.communication.sendCommand(
            self.psd.asciiAddress,
            cmd + self.psd.command.executeCommandBuffer(),
            waitForPump=False)


class LegacyArchitecture():
    """Represents the Legacy Architecture, with many valves and
    reservoirs, connected to an input syringe pump, connected to
    the sample, connected to an output/waste syringe pump.
    """
    valve_a = {}
    pump_a = None
    pump_out = None
    tubing_config = {}
    reservoir_a = []
    # maps reservoir ids to the fluid paths (legacy only has 'a')
    reservoir_paths = {}
    protocol = []
    last_protocol_entry = -1

    extractionfactor = 1

    def __init__(self):
        pass

    def _assign_system_config(self, config):
        """Assign a system configuration
        Args:
            config : dict
                the system configuration
        """
        assert config['system_type'] == 'legacy'
        for vconfig in config['valve_a']:
            self.valve_a[vconfig['address']] = Valve(**vconfig)
        for rconfig in config['reservoir_a']:
            self.reservoir_a[rconfig['id']] = Reservoir(**rconfig)
            self.reservoir_paths[rconfig['id']] = 'a'
        self.pump_a = Pump(**config['pump_a'])
        self.pump_out = Pump(**config['pump_out'])

    def _assign_protocol(self, protocol):
        self.protocol = protocol['protocol_entries']
        self.flow_parameters = protocol['flow_parameters']:

    def _assign_tubing_config(self, config):
        self.tubing_config = config

    def perform_next_protocol_entry(self):
        """Performs the next entry in the dispension protocol
        """
        if last_protocol_entry == -1:
            self._assemble_tubing_column(0)
        curr_protocol_entry = self.last_protocol_entry + 1
        for reservoir_id, vol in self.tubing_column[curr_protocol_entry]:
            self._set_valves(reservoir_id)
            self._inject(vol)
        self.last_protocol_entry = curr_protocol_entry

    def jump_to_protocol_entry(self, i):
        """When not executing the next protocol entry but jumpint to one
        out of order, the tubing-'column' needs to be re-assembled.

        A protocol entry consists of:
            type, parameters.
        e.g.
            type='inject', reserviorID, volume, speed, extractionfactor
            type='wait_image',
            type='wait_time', duration
        """
        self._assemble_tubing_column(i)
        for reservoir_id, vol in self.tubing_column[i]:
            self._set_valves(reservoir_id)
            self._inject(vol)
        self.last_protocol_entry = i

    def execute_single_protocol_entry(self, i):
        """Execute only one single entry of the protocol; do not fill the
        tubing with the (potentially precious) later protocol entry fluids,
        but with buffer.
        """
        pentry = self.protocol[i]
        if pentry['type'] == 'dispense':
            flush_volume = self._calc_vol_to_inlet(pentry['reservoir_id'])
            injection_volume = pentry['volume']
            # first, set up the volume required
            self._set_valves(pentry['reservoir_id'])
            self._inject(injection_volume, pentry['speed'])
            # afterwards, flush in buffer to get the pentry volume to the sample
            self._set_valves(self.config['flushbuffer_a'])
            self._inject(flush_volume, pentry['speed'])

        self.last_protocol_entry = -1  # tubing full of buffer, cannot simply proceed

    def _assemble_tubing_column(self, i):
        """Assemble the 'column' of different fluids stacked into the tubing.
        In an efficient delivery, when delivering fluid of step i into the
        sample, the tubing already needs to be switched to fluids of later steps.

        Args:
            i : int
                the protocol step to start with
        Returns:
            column : dict
                keys: protocol step
                values: list of injection tuples with (reservoir_a_id, volume)
        """
        column = {}
        nsteps = len(self.protocol[i:])
        reservoirs = np.zeros(nsteps + 1, dtype=np.int32)
        volumes = np.zeros(nsteps + 1, dtype=np.float64)

        for idx, pentry in enumerate(self.protocol[i:]):
            if pentry['type'] != 'dispense':
                continue
            reservoirs[idx] = pentry['reservoir_id']
            volumes = pentry['volume']
        reservoirs[-1] = self.config['flushbuffer_a']
        volumes[-1] = self._calc_vol_to_inlet(reservoirs[-1])

        volumes_cum = np.cumsum(volumes)

        for idx, step in enumerate(range(start=i, stop=i + nsteps)):
            injection_tuples = []
            if idx == 0:
                vol = (
                    volumes[idx]
                    + self._calc_vol_to_inlet(reservoirs[idx]))
            else:
                vol = (
                    volumes[idx]
                    + self._calc_vol_to_inlet(reservoirs[idx])
                    - self._calc_vol_to_inlet(reservoirs[idx - 1]))
            vol_rest = vol
            cum_start = np.argwhere(volumes_cum > 0).flatten()[0]
            cum_stop = np.arghwere(volumes_cum < vol).flatten()[0]
            for cum_idx in range(cum_start, cum_stop):
                vol_step = min([vol_rest, volumes_cum[cum_idx]])
                injection_tuples.append(tuple(
                    reservoirs[cum_idx],
                    vol_step))
                volumes_cum -= vol_step
                vol_rest -= vol_step
            column[step] = injection_tuples
        self.tubing_column = column

    def _calc_vol_to_inlet(self, reservoir_id):
        """Calculates the tubing volume between reservoir and inlet needle
        from the tubing configuration. This is legacy system specific
        """
        vol_res_pump_a = self.tubing_config[(reservoir_id, 'pump_a')]
        vol_pump_a_inlet = self.tubing_config[('pump_a', 'sample')]
        return vol_res_pump_a + vol_pump_a_inlet

    def _set_valves(self, reservoir_id):
        """Set the valves to access the reservoir specified
        """
        if self.reservoir_paths[reservoir_id] == 'a':
            valve_positions = self.reservoir_a[reservoir_id].get_valve_positions()
            for valve, pos in valve_positions.items():
                self.valve_a[valve].set(pos)
        else:
            raise NotImplmentedError('Legacy system only has fluid path "a".')

    def _inject(self, vol, velocity=None, extractionfactor=None):
        """Inject volume from the currently selected reservoir into
        the sample with a given flow velocity. Simultaneously, the extraction
        pump extracts the same volume.

        Args:
            vol : float
                the volume to inject in µl
            velocity : float
                the flow velocity of the injection in µl/min
            extractionfactor : float
                the factor of flow speeds of extraction vs injection.
                a non-perfectly calibrated system may result in less volume
                being extracted than injected, leading to spillage. To prevent
                this, the extraction needle could be positioned higher, and
                extraction performed faster than injection
        """
        if velocity is None:
            velocity = self.flow_parameters['max_velocity']
        if extractionfactor is None:
            extractionfactor = self.flow_parameters['extractionfactor']
        if self.pump_a.curr_vol > 0:
            self.pump_a.set_valve('out')
            self.pump_out.set_valve('in')
            self.pump_a.dispense(self.pump_a.curr_vol, velocity)
            self.pump_out.pickup(
                self.pump_a.curr_vol * extractionfactor,
                velocity * extractionfactor)
            self.pump_a.wait_till_done()
            self.pump_out.wait_till_done()

        volume_quant = max([
            self.pump_a.syringe_volume,
            self.pump_out.syringe_volume / extractionfactor])
        nr_pumpings = vol // volume_quant
        pump_volumes = volume_quant * np.ones(nr_pumpings + 1)
        pump_volumes[-1] = vol % volume_quant

        for pump_volume in pump_volumes:
            self.pump_a.set_valve('in')
            self.pump_out.set_valve('out')
            self.pump_a.pickup(pump_volume, velocity)
            self.pump_out.dispense(
                self.pump_a.curr_vol * extractionfactor,
                velocity * extractionfactor)
            self.pump_a.wait_till_done()
            self.pump_out.wait_till_done()

            self.pump_a.set_valve('out')
            self.pump_out.set_valve('in')
            self.pump_a.dispense(pump_volume, velocity)
            self.pump_out.pickup(
                pump_volume * extractionfactor,
                velocity * extractionfactor)
            self.pump_a.wait_till_done()
            self.pump_out.wait_till_done()

        self.pump_out.set_valve('out')
        self.pump_out.dispense(
            self.pump_a.curr_vol * extractionfactor,
            velocity * extractionfactor)
        self.pump_out.wait_till_done()


"""
Diluter system architecture:
* a1) N valves for N*6+1 secondary probe reservoirs ('valve_a')
* a2) 1 syringe pump for reservoirs ('pump_a')

* b) 1 syringe pump for 1 buffer ('pump_b')
* c1) 1 valve for selecting imagers ('valve_c')
* c2) 1 syringe pump for pumping imagers ('pump_b')
* bc) 1 passive connection combining a and b ('conflux_bc')

* abc) 1 valve switching between ab and c ('conflux_abc')

* sample

* 1 syringe pump ('pump_out')
* waste
"""
diluter_system_config = {
    'system_type': 'diluter',
    'valve_a': [
        {'address': 0, 'intrument_type': 'MVP', 'valve_type': '8-way'},
        {'address': 1, 'intrument_type': 'MVP', 'valve_type': '8-way'}],
    'valve_c': [
        {'address': 2, 'intrument_type': 'MVP', 'valve_type': '8-way'}],
    'reservoir_a': [
        {'id': 0, 'valve_pos': {0: 1, 1: 1, 7: 1}},
        {'id': 1, 'valve_pos': {0: 1, 1: 2, 7: 1}},
        {'id': 2, 'valve_pos': {0: 3, 1: 1, 7: 1}}],
    'reservoir_b': [
        {'id': 3, 'valve_pos': {7: 2}}],
    'reservoir_c': [
        {'id': 4, 'valve_pos': {2: 2, 7: 2}},
        {'id': 5, 'valve_pos': {2: 3, 7: 2}}],
    'pump_a': {'address': 3, 'instrument_type': 'PSD4', 'valve_type': 'Y', 'syringe': '500µl'},
    'pump_b': {'address': 4, 'instrument_type': 'PSD4', 'valve_type': 'Y', 'syringe': '500µl'},
    'pump_c': {'address': 5, 'instrument_type': 'PSD4', 'valve_type': 'Y', 'syringe': '50µl'},
    'pump_out': {'address': 6, 'instrument_type': 'PSD4', 'valve_type': 'Y', 'syringe': '500µl'},
    'conflux_bc': {'instrument_type': 'passive'},
    'conflux_abc': {'address': 7, 'instrument_type': 'MVP', 'valve_type': '4-way'},
}

diluter_tubing_config = {
    (0, 'pump_a'): 153.2,
    (1, 'pump_a'): 151.8,
    ('pump_a', 'conflux_abc'): 30.7,
    (3, 'pump_b'): 11.8,
    (4, 'pump_c'): 15.8,
    (5, 'pump_c'): 16.8,
    ('pump_b', 'conflux_bc'): 12,
    ('pump_c', 'conflux_bc'): 13,
    ('conflux_bc', 'conflux_abc'): 31,
    ('conflux_abc', 'sample'): 28
}


class DiltuterArchitecture(LegacyArchitecture):
    """
    """

    def __init__(self):
        pass

    def mix_injection(self):
        """Same as inject, only two input syringes have to be actuated simultaneously,
        with the correct relative flow speed. More a matter of the experiment protocol
        specifying the pump(s) to use
        """
        pass



experiment_config = {
    'reservoir_names': {
        0: 'Buffer B+',
        1: 'Imager 50pM',
    }
}